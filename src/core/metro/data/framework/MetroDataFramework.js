// modules/metro/data/framework/MetroDataFramework.js
// modules/metro/data/framework/MetroDataFramework.js
const { mkdirSync, accessSync } = require('fs');
const fs = require('fs').promises;
const path = require('path');
const EventEmitter = require('events');

class MetroDataFramework {
  constructor(options = {}) {
    this.basePath = options.basePath || './metro-data/stations';
    this.autoGenerate = options.autoGenerate !== false;
    this.emitter = options.emitter || new EventEmitter();
    this.loadedData = { stations: {}, lines: {} };

    // Bind methods
    this.getLineColor = this.getLineColor.bind(this);
    this._sanitizeFilename = this._sanitizeFilename.bind(this);
  }

  /* Public API */

  async loadNetwork() {
    try {
      this._ensureBaseStructure();
      const lineDirs = await this._getLineDirectories();
      
      for (const lineId of lineDirs) {
        await this._loadLine(lineId);
      }

      return this.loadedData;
    } catch (error) {
      this.emitter.emit('error', error);
      throw error;
    }
  }

  async getStation(lineId, stationId) {
    const stationKey = this._createStationKey(lineId, stationId);
    return this.loadedData.stations[stationKey] || null;
  }

  async updateStation(lineId, stationId, data) {
    try {
      const stationKey = this._createStationKey(lineId, stationId);
      const stationPath = this._getStationPath(lineId, data.basicInfo?.code || stationId);

      this._ensureLineDirectory(lineId);
      
      const updatedData = {
        ...data,
        _meta: {
          ...(data._meta || {}),
          lastUpdated: new Date().toISOString()
        }
      };

      await fs.writeFile(stationPath, JSON.stringify(updatedData, null, 2));
      this.loadedData.stations[stationKey] = updatedData;
      
      this.emitter.emit('stationUpdated', { lineId, stationId });
      return true;
    } catch (error) {
      this.emitter.emit('error', error);
      throw error;
    }
  }

  /* Station Code Helpers */

  getLineColor(lineId) {
    const lineColors = {
      l1: '#e2001a', l2: '#f8b61c', l3: '#8cc63f',
      l4: '#00a1e4', l4a: '#00a1e4', l5: '#a05eb5',
      l6: '#d85e27'
    };
    return lineColors[lineId.toLowerCase()] || '#cccccc';
  }

  /* Internal Methods */

  async _loadLine(lineId) {
    const linePath = path.join(this.basePath, lineId);
    const stationFiles = await this._getStationFiles(lineId);

    for (const stationFile of stationFiles) {
      const stationId = path.basename(stationFile, '.json');
      const stationKey = this._createStationKey(lineId, stationId);
      
      try {
        const data = await fs.readFile(path.join(linePath, stationFile), 'utf8');
        this.loadedData.stations[stationKey] = JSON.parse(data);
      } catch (error) {
        if (this.autoGenerate && error.code === 'ENOENT') {
          this.loadedData.stations[stationKey] = this._createDefaultStation(lineId, stationId);
        } else {
          throw error;
        }
      }
    }
  }

  _getStationPath(lineId, stationIdentifier) {
    return path.join(
      this.basePath,
      lineId.toLowerCase(),
      `${this._sanitizeFilename(stationIdentifier)}.json`
    );
  }

  _sanitizeFilename(name) {
    return name.replace(/[^a-zA-Z0-9áéíóúÁÉÍÓÚñÑ_\-]/g, '_');
  }

  _createStationKey(lineId, stationId) {
    return `${lineId.toLowerCase()}:${stationId.toLowerCase()}`;
  }

  _ensureBaseStructure() {
    try {
      accessSync(this.basePath);
    } catch {
      mkdirSync(this.basePath, { recursive: true });
    }
  }

  _ensureLineDirectory(lineId) {
    const linePath = path.join(this.basePath, lineId);
    try {
      accessSync(linePath);
    } catch {
      mkdirSync(linePath, { recursive: true });
    }
  }

  async _getLineDirectories() {
    try {
      const items = await fs.readdir(this.basePath);
      return items.filter(item => item.match(/^l[1-6]$|^l4a$/i));
    } catch {
      return [];
    }
  }

  async _getStationFiles(lineId) {
    try {
      const linePath = path.join(this.basePath, lineId);
      const items = await fs.readdir(linePath);
      return items.filter(item => item.endsWith('.json'));
    } catch {
      return [];
    }
  }

  _createDefaultStation(lineId, stationId) {
    return {
      _meta: {
        version: 1,
        generatedAt: new Date().toISOString(),
        autoGenerated: true
      },
      basicInfo: {
        id: stationId,
        lineId,
        name: stationId.replace(/_/g, ' '),
        code: stationId.substring(0, 3).toUpperCase(),
        color: this.getLineColor(lineId)
      },
      status: { code: '0', description: 'operational' },
      services: {},
      access: { points: [], accessibility: [] },
      connections: { transports: [], bikes: [] },
      amenities: [],
      commerce: [],
      schematics: [],
      images: []
    };
  }
}

module.exports = MetroDataFramework;
